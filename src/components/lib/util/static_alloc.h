/**
 * Redistribution of this file is permitted under the BSD two clause license.
 *
 * Copyright 2020, The George Washington University
 * Author: Gabriel Parmer, gparmer@gwu.edu
 */

#ifndef STATIC_ALLOC_H
#define STATIC_ALLOC_H

#include <ps.h>
#include <cos_debug.h>

/***
 * The second API similarly provides the logic for allocation and
 * access implementing the following potential state machine
 * transitions:
 *
 * - free -> constructing
 * - constructing -> allocated
 * - constructing -> free
 * - allocated -> free
 *
 * When in the *free* state, an item can be constructed, and its
 * memory should not be accessed. When it is in the *constructed*
 * state, the item's memory should not be accessed as it is still
 * being prepared.
 *
 * This API enables the *state* of the item to be embedded with a
 * pointer. It assumes that pointers have a the least significant bit
 * set to 0.
 *
 * The implementation takes care to interpret a `0` value as *free*,
 * so that it can be applied to items in the BSS without
 * initialization.  Both constructing and allocated are `!0`.
 * Constructing has the least significant bit `!= 0`, while allocated
 * has it `== 0`. The value must include a pointer if allocated (thus
 * resulting in the entire word being `!= 0`), while the pointer can
 * be `0` or not if constructing.
 */
typedef word_t sa_state_t;
/* if we don't need to store a pointer, use this instead of NULL */
#define SA_STATE_NULLPTR (void *)(~1)
/*
 * This is used for documentation of what the pointer type is even
 * though it is encapsulated in the sa_state_t
 */
#define SA_STATE_T(type) sa_state_t

/* State encodings in the least significant bit. */
#define SA_STATE_FREE	0	/* free */
#define SA_STATE_CONS	1	/* constructing */
#define SA_STATE_ALLOC	0	/* allocated */

/**
 * Move the memory into the constructing state. Can fail due to
 * concurrent/parallel allocation of the same memory.
 *
 * - @state - the state + ptr
 * - @return - `0` = success, `1` = failure
 */
static inline int
sa_state_alloc(sa_state_t *state) /* free->constructing */
{
	if (*state != SA_STATE_FREE ||
	    !ps_cas(state, SA_STATE_FREE, SA_STATE_CONS)) return 1;

	return 0;
}

/**
 * Activate constructing memory. CAS is not required here as we should
 * have exclusive access.
 */
static inline void
sa_state_activate(sa_state_t *state) /* constructing->allocated */
{
	assert((*state & 1) == SA_STATE_CONS);
	*state &= ~SA_STATE_CONS;
	ps_mem_fence();	/* make sure that the previous writes are committed */
	/* Note that this assumes that the pointer has been set */
	assert(*state != 0);
}

static inline void
sa_state_free(sa_state_t *state) /* (constructing|allocated)->free */
{
	assert(*state != 0);
	*state = SA_STATE_FREE;
}

static inline int
sa_state_is_allocated(sa_state_t state)
{
	return (state != 0) && ((state & 1) == SA_STATE_ALLOC);
}

static inline int
sa_state_is_free(sa_state_t state)
{
	return state == 0;
}

/**
 * This should only be used on allocated memory.
 */
static inline void *
sa_state_ptr_get(sa_state_t state)
{
	assert(((state & 1) == SA_STATE_ALLOC) && ((state & ~1) != 0));
	return (void*)(state & ~1);
}

/**
 * This can be used on constructing or allocated memory, and it does
 * *not* change the state.
 */
static inline void
sa_state_ptr_set(sa_state_t *state, void *ptr)
{
	assert(*state != 0);
	*state = (word_t)ptr | (*state & 1);
}

/**
 * Store a pointer in the state *and* activate the memory.
 */
static inline void
sa_state_activate_with(sa_state_t *state, void *ptr)
{
	sa_state_ptr_set(state, ptr);
	sa_state_activate(state);
}

/**
 * A memory allocator for statically-allocated collections of
 * objects. Similar to an API, and a baby version of parsec
 * namespaces. Objects are tracked as state machines of object
 * initialization, use, and freeing. This structure supports *indexed*
 * lookups, thus providing a facility to map a token/descriptor to an
 * object. This is mainly useful in system code that shares these
 * descriptors between protection domains (where pointers are
 * invalid). The implementation tracks the allocation state of an
 * object, *and* provides some rudimentary synchronization for indexed
 * lookups.
 *
 * The API is generated by the `SA_STATIC_ALLOC` macro, specialized to
 * the specific type. This enables the alignment constraints of the
 * underlying type to be factored into the global allocation, and
 * avoids magic math based on the size of the object type. It also
 * mimics the typical slab allocator interface.
 *
 * *The API*:
 * - `SA_STATIC_ALLOC(name, type, max_num_objects)` - Create the global
 *   memory for the objects to be able to allocate `max_num_objects`
 *   number of objects, and the following functions.
 * - `type *sa_name_alloc()` - Allocate a new object of the
 *   specified type. This is not fast. It is linear in max_num_objects.
 * - `void sa_name_free(type *obj)` - Free an allocated object,
 *   `obj`.
 * - `type *sa_name_alloc_at_index(unsigned int idx)` -
 *   Allocate an object at a descriptor `idx`.
 * - `void sa_name_activate(type *obj)` - Made an object
 *   accessible through indexed lookups.
 * - `type *sa_name_get(unsigned int idx) - Lookup an object via
 *   descriptor `idx` and return it if it is active.
 * - `unsigned int sa_name_index(type *obj)` - return the index
 *   of the object.
 *
 * *Example*:
 * ```
 * SA_STATIC_ALLOC(comp, struct crt_comp, MAX_NUM_COMPS);
 *
 * struct crt_comp *
 * comp_alloc(compid_t *cid)
 * {
 * 	struct crt_comp *c = sa_comp_alloc();
 *
 * 	if (!c) return NULL;
 * 	*cid = sa_comp_index(c);
 * 	// initialize the component
 * 	sa_comp_activate(c);
 *
 * 	return c;
 * }
 *
 * int
 * comp_free(compid_t id)
 * {
 * 	struct crt_comp *c sa_comp_get(id);
 *
 * 	if (!c) return -ENVAL;
 * 	sa_comp_free(c);
 *
 *	return 0;
 * }
 * ```
 *
 * *Synchronization*: It is important to further discuss the
 * interaction between `activate` and `get`. An object transitions
 * from `free` to `constructing` to denote that it's memory is in use,
 * but it is *not* yet accessible for indexed lookups. At this point,
 * an indexed lookup will return false. After the object is
 * initialized properly (denoted by `*_activate`), it transitions into
 * `allocated` and accessible for indexed lookups.
 *
 * This is all of the synchronization necessary to track allocations,
 * and for objects that are read-only, or can handle modification in
 * place (e.g. by wrapping them with a lock, or using atomic
 * instructions).
 *
 * *Allocator metadata*: The implementation uses a separation between
 * meta-data (allocation states) from the allocated memory. It
 * allocates a word to each object's meta-data, thus giving a wastage
 * fraction of sizeof(word_t)/(sizeof(type) + sizeof(word_t)). We
 * don't use bitfields for the meta-data as we don't want potential
 * cas contention *between* different objects. This would require
 * unbounded `cas` loops that are unacceptable. We pay for this with
 * some memory wastage.
 *
 * *Id API*: The API has `*_offset` APIs that are internal, and `*_id`
 * *APIs. The id* APIs view the static allocation space as
 *
 * 1. Offset into the id namespace by `id_offset`. For example, an
 *    `id_offset = 1`, means that `id = 1` is the 0th item in the
 *    static allocation array.
 * 2. The ids are in the range `[id_offset, id_offset + max_num)`.
 *
 * *Guarantees*:
 *
 * - All allocation is through the static array. No dynamic allocation.
 * - Constant-time (array indexed) `get`.
 * - Constant-time `alloc_at_index`.
 * - Objects are laid out contiguously. Alignment constraints should
 *   be embedded into your object/struct type, and they are honored.
 * - Statically allocated memory is BSS-allocated.
 * - Atomic instruction-guaranteed failure of `get` if an object has
 *   not been `activate`d.
 *
 * *Assumptions*:
 *
 * - This macro must be used in the same compilation object (`.o`) in
 *   which it is used. It does *not* generate function prototypes to
 *   be exported, and all data is `static`. Wrap these if you want to
 *   export them. The main macro should *never* be used in a header.
 * - After allocation and preparation of the object, you'll call
 *   `activated` if you're using the indexed allocation mechanism.
 * - The implementation uses `cas` to prevent races on allocation.
 */

#define SA_STATIC_ALLOC_OFF(name, type, max_num, id_offset)		\
	static sa_state_t sa_##name##_states[max_num];			\
	static type sa_##name##_globals[max_num];			\
									\
	static type *	/* Not part of the public API */		\
	__sa_##name##_alloc_at_index(unsigned int idx)			\
	{								\
		type *c = NULL;						\
		sa_state_t *s;						\
									\
		if (idx >= max_num) return NULL;			\
		c = &sa_##name##_globals[idx];				\
		s = &sa_##name##_states[idx];				\
		if (sa_state_alloc(s)) return NULL;			\
		memset(c, 0, sizeof(type));				\
									\
		return c;						\
	}								\
	static type *							\
	sa_##name##_alloc_at_id(unsigned int id)			\
	{								\
		if (id < id_offset) return NULL;			\
									\
		return __sa_##name##_alloc_at_index(id - id_offset);	\
	}								\
	static type *							\
	sa_##name##_alloc(void)						\
	{								\
		unsigned int i;						\
		type *c = NULL;						\
									\
		for (i = 0; i < max_num; i++) {				\
			c = __sa_##name##_alloc_at_index(i);		\
			if (c) break;					\
		}							\
		if (i >= max_num) return NULL;				\
									\
		return c;						\
	}								\
	static unsigned int						\
	__sa_##name##_index(type *o) /* not part of the public API */	\
	{								\
		assert(o >= &sa_##name##_globals[0] &&			\
		       o <= &sa_##name##_globals[max_num - 1]);		\
									\
		return (o - &sa_##name##_globals[0]);			\
	}								\
	static unsigned int						\
	sa_##name##_id(type *o)						\
	{								\
		return __sa_##name##_index(o) + id_offset;		\
	}								\
	static void							\
	sa_##name##_activate(type *o)					\
	{								\
		unsigned int idx = __sa_##name##_index(o);		\
		sa_state_t *s    = &sa_##name##_states[idx];		\
									\
		sa_state_activate_with(s, SA_STATE_NULLPTR);		\
	}								\
	static void							\
	sa_##name##_free(type *o)					\
	{								\
		unsigned int idx = __sa_##name##_index(o);		\
									\
		sa_state_free(&sa_##name##_states[idx]);		\
	}								\
	static type *							\
	sa_##name##_get(unsigned int id)				\
	{								\
		type *o;						\
		unsigned int idx;					\
									\
		if (id < id_offset) return NULL;			\
		idx = id - id_offset;					\
		if (idx >= max_num) return NULL;			\
		o = &sa_##name##_globals[idx];				\
		if (!sa_state_is_allocated(sa_##name##_states[idx])) return NULL; \
									\
		return o;						\
	}								\
	int								\
	sa_##name##_is_allocated(type *o)				\
	{								\
		unsigned int idx = __sa_##name##_index(o);		\
									\
		return !sa_state_is_allocated(sa_##name##_states[idx]);	\
	}

#define SA_STATIC_ALLOC(name, type, max_num) SA_STATIC_ALLOC_OFF(name, type, max_num, 0)

#endif	/* STATIC_ALLOC_H */
