# FIXME: Note: I have added -fno-merge-constants so that all strings
# will be placed in the .rodata section as opposed to .rodata.str1.x |
# x in uints
#
# -Xlinker -r is used to pass flags into the linker, in this case to
# prevent musllibc from creating an executable and linking in many of
# its normal symbols

# I never want to touch this again, but will have to

include Makefile.src Makefile.comp

COMPPATH=$(subst /, ,$(shell pwd))
COMPLEN=$(words $(COMPPATH))
COMPLIST=$(wordlist $(shell echo $(COMPLEN)-1 | bc), $(COMPLEN), $(COMPPATH))
COMPNAME=$(shell echo $(strip $(COMPLIST)) | sed "s/ /./")
COMPOBJ=$(COMPNAME).o

# These are compiled in with the components regardless of if they
# export an undefined symbol from the component.  They are a manditory
# link-in.
LIB_ASM_MANDITORY=$(LIBDIR)/$(MANDITORY_LIB)

# Derive the include paths from both the interface encoded in the
# directory hierarchy, and the explicit DEPENDENCIES specification
INTERFACE=$(word $(shell echo $(COMPLEN)-1 | bc), $(COMPPATH))
ALL_INTERFACES = $(sort $(INTERFACE) $(INTERFACES)) # sort is for uniq
# include paths for each interface
EXPIF_INC_PATHS=$(foreach I,$(ALL_INTERFACES),-I$(INTERDIR)/$(I)/)
# Server libraries for components that implement an interface (only if they exist).
EXPIF_LIB_PATHS=$(foreach I,$(ALL_INTERFACES), $(if $(wildcard $(IMPLDIR)/$(I)/libs_$(I).a), -L$(IMPLDIR)/$(I)/))
EXPIF_LIBS=$(foreach I,$(ALL_INTERFACES), $(if $(wildcard $(IMPLDIR)/$(I)/libs_$(I).a), -ls_$(I)))

# every component is dependent on init
DEPENDENCIES += init
# Paths and libraries derived from the interface dependencies that
# components have defined (only if the libraries exist).
DEP_INC_PATHS=$(foreach D,$(DEPENDENCIES),-I$(INTERDIR)/$(D)/)
DEP_LIB_PATHS=$(foreach D,$(DEPENDENCIES),$(if $(wildcard $(INTERDIR)/$(D)/libc_$(D).a), -L$(INTERDIR)/$(D)/)
DEP_LIBS=$(foreach D,$(DEPENDENCIES),$(if $(wildcard $(INTERDIR)/$(D)/libc_$(D).a), -lc_$(D))

C_OBJS=$(patsubst %.c,%.o,$(wildcard *.c))
CXX_OBJS=$(patsubst %.cc,%.o,$(wildcard *.cc))
ASM_OBJS=$(patsubst %.S,%.o,$(wildcard *.S))
OBJS=$(CXX_OBJS) $(C_OBJS) $(ASM_OBJS) $(OBJLIBS)

# put together all of the paths and libraries into command line
# arguments
INCLUDE=-I../ $(DEP_INC_PATHS) $(EXPIF_INC_PATHS)
LIB_FLAGS=-L$(LIBDIR) -L$(LIBCXXDIR) -L$(CKLIBDIR) -L$(LIBDIR)/sinv_async/ $(EXPIF_LIB_PATHS) $(EXPIF_LIBS) $(ADDITIONAL_LIBS)

#NOTE: assembly files don't have dependencies generated for them
SOURCE_DEPENDENCIES=$(C_OBJS:%.o=%.d) $(CXX_OBJS:%.o=%.d)

COMP_LD_SCRIPT=$(IMPLDIR)/comp.ld

TAR_SYMBOL_NAME=crt_init.tar

.PHONY: all
all: print $(SOURCE_DEPENDENCIES) $(COMPOBJ)

print:
	$(info | Component $(COMPNAME):)

# Jumping through hoops: want to link to our libraries first so that
# symbols there are used, but then (and only then) do we want to use
# libc's functions as part of the "component" directive
$(COMPOBJ): $(OBJS)
	$(info |     [LD]   $(COMPNAME) ($@): Linking $(if $(strip $(LIB_LIBRARIES)),$(LIB_LIBRARIES)) $^)
	@$(LD) $(LDFLAGS) -r -o $@ $^ $(LIB_ASM_MANDITORY) $(LIB_FLAGS)

# make COMP_INTERFACE=pong COMP_NAME=pingpong COMP_OBJNAME=IT.WORKS COMP_OUTPUT=pong.pingpong.pong.o component

# These variables direct the compilation and are set by the highest-level make command
# Note that they are all passed in as "if_0/var_0+if_1/var_1+...", so we need to remove the + and the "
COMP_INTERFACES_CLEAN=$(strip $(subst +, ,$(subst ",,$(COMP_INTERFACES)))) #"
COMP_IFDEPS_CLEAN=$(strip $(subst +, ,$(subst ",,$(COMP_IFDEPS)))) #"
COMP_LIBDEPS_CLEAN=$(strip $(subst +, ,$(subst ", ,$(COMP_LIBDEPS)))) #"

# The actual lists of objects to be compiled with the components...
COMP_EXPIF_OBJS=$(foreach I,$(COMP_INTERFACES_CLEAN),$(INTERDIR)/$(I)/cosrt_s_stub.o)
COMP_DEP_OBJS=$(foreach D,$(COMP_IFDEPS_CLEAN),$(INTERDIR)/$(D)/cosrt_c_stub.o)

# NOTE: we're currently ignoring the libraries, which will break if an
# interface's code requires a library

component:
	$(info | Sealing $(COMP_INTERFACE).$(COMP_NAME) for variable $(COMP_VARNAME) by linking with:)
	$(info |     Exported interfaces: $(COMP_INTERFACES_CLEAN))
	$(info |     Interface dependencies: $(COMP_IFDEPS_CLEAN))
	$(info |     Libraries: $(COMP_LIBDEPS_CLEAN) (currently ignored))
	$(if $(COMP_INITARGS_FILE), $(CC) $(INCLUDE) -I$(CDIR)/include/initargs/ $(CFLAGS) -c -o $(COMP_INITARGS_FILE:%.c=%.o) $(COMP_INITARGS_FILE))
	$(if $(COMP_TAR_FILE), cp $(COMP_TAR_FILE) $(TAR_SYMBOL_NAME))
	$(if $(COMP_TAR_FILE), $(LD) $(LDFLAGS) -r -b binary $(TAR_SYMBOL_NAME) -o $(COMP_TAR_FILE).o; rm $(TAR_SYMBOL_NAME))
	$(LD) $(LDFLAGS) -r -o $(COMPNAME).linked_libs_ifs.o $(COMPOBJ) $(COMP_EXPIF_OBJS) $(COMP_DEP_OBJS) $(if $(COMP_INITARGS_FILE), $(COMP_INITARGS_FILE:%.c=%.o)) $(if $(COMP_TAR_FILE), $(COMP_TAR_FILE).o)
	$(MUSLCC) $(COMPNAME).linked_libs_ifs.o $(MUSLCFLAGS) -Xlinker -melf_i386 -o $(COMPNAME).linked_musl.o
	$(LD) $(LDFLAGS) -Ttext=$(COMP_BASEADDR) -T $(COMP_LD_SCRIPT) -o $(COMP_OUTPUT) $(COMPNAME).linked_musl.o

%.o:%.c
	$(info |     [CC]   $<: Compiling)
	@$(CC) $(INCLUDE) $(CFLAGS) -o $@ -c $<

%.o:%.cc
	$(info |     [CXX]  $<: Compiling)
	@$(CXX) $(INCLUDE) $(LIBSTDCXXINC) $(CXXFLAGS) -o $@ -c $<

%.o:%.S
	$(info |     [AS]   Compiling assembly file $^ into $@)
#	$(info |     [AS]   $<: Compiling)
	@$(AS) $(INCLUDE) $(ASFLAGS) -c -o $@ $^

# see the make manual: create the .d dependencies from include
# statements.
%.d:%.c
	@set -e; rm -f $@; \
	$(CC) -M $(INCLUDE) $(CFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

%.d:%.cc
#	$(info |     [DEP]  Creating dependency file for $<)
	@set -e; rm -f $@; \
	$(CXX) -M $(INCLUDE) $(LIBSTDCXXINC) $(CXXFLAGS) $< > $@.$$$$; \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
	rm -f $@.$$$$

.PHONY: cp
cp:
	$(info |     [CP]   Copying $(COMPNAME) to $(TRANS_DIR))
	@cp $(COMPOBJ) $(TRANS_DIR)/

.PHONY: clean
clean:
	$(info |     [RM]   Cleaning up implementation directory for component $(COMPNAME))
	@rm -f a.out *.o *.a *.d *.d.* *~

fresh: clean all

-include $(SOURCE_DEPENDENCIES)
